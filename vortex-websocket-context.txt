'use client'

import React, { createContext, useContext, useEffect, useState, useRef, useCallback } from 'react'
import { io, Socket } from 'socket.io-client'
import { getCookie } from '@/lib/cookies'
import { useAuth } from '@/contexts/auth-context'
import toast from 'react-hot-toast'

interface WebSocketContextType {
  socket: Socket | null
  connected: boolean
  subscribe: (event: string, handler: (data: any) => void) => void
  unsubscribe: (event: string, handler?: (data: any) => void) => void
  emit: (event: string, data?: any) => void
  reconnect: () => void
}

const WebSocketContext = createContext<WebSocketContextType | undefined>(undefined)

export function WebSocketProvider({ children }: { children: React.ReactNode }) {
  const { isAuthenticated } = useAuth()
  const [socket, setSocket] = useState<Socket | null>(null)
  const [connected, setConnected] = useState(false)
  const reconnectTimeoutRef = useRef<NodeJS.Timeout>()
  const reconnectAttemptsRef = useRef(0)
  const maxReconnectAttempts = 5
  const eventHandlersRef = useRef<Map<string, Set<(data: any) => void>>>(new Map())

  // Инициализация сокета
  const initSocket = useCallback(() => {
    if (!isAuthenticated) return

    const token = getCookie('access_token')
    if (!token) return

    const socketUrl = process.env.NEXT_PUBLIC_WS_URL || 'http://localhost:8080'
    
    const newSocket = io(socketUrl, {
      auth: {
        token,
      },
      transports: ['websocket', 'polling'],
      reconnection: true,
      reconnectionAttempts: maxReconnectAttempts,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
    })

    // Обработчики событий подключения
    newSocket.on('connect', () => {
      console.log('WebSocket connected')
      setConnected(true)
      reconnectAttemptsRef.current = 0
      
      // Переподписываемся на все события
      eventHandlersRef.current.forEach((handlers, event) => {
        handlers.forEach(handler => {
          newSocket.on(event, handler)
        })
      })
    })

    newSocket.on('disconnect', (reason) => {
      console.log('WebSocket disconnected:', reason)
      setConnected(false)
      
      // Попытка переподключения при непредвиденном отключении
      if (reason === 'io server disconnect') {
        // Сервер принудительно отключил, возможно токен истек
        handleReconnect()
      }
    })

    newSocket.on('connect_error', (error) => {
      console.error('WebSocket connection error:', error)
      
      if (error.message === 'Unauthorized') {
        toast.error('Ошибка авторизации WebSocket')
      }
    })

    // Системные события
    newSocket.on('notification', (data) => {
      handleNotification(data)
    })

    newSocket.on('error', (error) => {
      console.error('WebSocket error:', error)
      toast.error('Ошибка WebSocket соединения')
    })

    setSocket(newSocket)

    return () => {
      newSocket.close()
    }
  }, [isAuthenticated])

  // Обработка уведомлений
  const handleNotification = useCallback((data: any) => {
    const { type, title, message } = data
    
    switch (type) {
      case 'info':
        toast(message, { icon: 'ℹ️' })
        break
      case 'success':
        toast.success(message)
        break
      case 'warning':
        toast(message, { icon: '⚠️' })
        break
      case 'error':
        toast.error(message)
        break
      default:
        toast(message)
    }

    // Показываем browser notification если разрешено
    if ('Notification' in window && Notification.permission === 'granted') {
      new Notification(title || 'VortexPanel', {
        body: message,
        icon: '/icon-192x192.png',
      })
    }
  }, [])

  // Переподключение
  const handleReconnect = useCallback(() => {
    if (reconnectAttemptsRef.current >= maxReconnectAttempts) {
      toast.error('Не удалось подключиться к серверу')
      return
    }

    reconnectAttemptsRef.current++
    
    const delay = Math.min(1000 * Math.pow(2, reconnectAttemptsRef.current - 1), 30000)
    
    reconnectTimeoutRef.current = setTimeout(() => {
      initSocket()
    }, delay)
  }, [initSocket])

  // Подписка на событие
  const subscribe = useCallback((event: string, handler: (data: any) => void) => {
    if (!eventHandlersRef.current.has(event)) {
      eventHandlersRef.current.set(event, new Set())
    }
    
    eventHandlersRef.current.get(event)!.add(handler)
    
    // Если сокет уже подключен, подписываемся сразу
    if (socket && connected) {
      socket.on(event, handler)
    }
  }, [socket, connected])

  // Отписка от события
  const unsubscribe = useCallback((event: string, handler?: (data: any) => void) => {
    if (!eventHandlersRef.current.has(event)) return
    
    const handlers = eventHandlersRef.current.get(event)!
    
    if (handler) {
      handlers.delete(handler)
      if (socket) {
        socket.off(event, handler)
      }
    } else {
      // Отписываемся от всех обработчиков события
      handlers.forEach(h => {
        if (socket) {
          socket.off(event, h)
        }
      })
      handlers.clear()
    }
    
    // Удаляем событие из карты, если нет обработчиков
    if (handlers.size === 0) {
      eventHandlersRef.current.delete(event)
    }
  }, [socket])

  // Отправка события
  const emit = useCallback((event: string, data?: any) => {
    if (!socket || !connected) {
      console.warn('WebSocket not connected, cannot emit event:', event)
      return
    }
    
    socket.emit(event, data)
  }, [socket, connected])

  // Переподключение вручную
  const reconnect = useCallback(() => {
    if (socket) {
      socket.close()
    }
    
    reconnectAttemptsRef.current = 0
    initSocket()
  }, [socket, initSocket])

  // Эффект для инициализации/очистки сокета
  useEffect(() => {
    if (isAuthenticated) {
      initSocket()
    } else if (socket) {
      socket.close()
      setSocket(null)
      setConnected(false)
    }

    return () => {
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current)
      }
      
      if (socket) {
        socket.close()
      }
    }
  }, [isAuthenticated, initSocket])

  // Запрос разрешения на уведомления
  useEffect(() => {
    if ('Notification' in window && Notification.permission === 'default') {
      Notification.requestPermission()
    }
  }, [])

  const value: WebSocketContextType = {
    socket,
    connected,
    subscribe,
    unsubscribe,
    emit,
    reconnect,
  }

  return (
    <WebSocketContext.Provider value={value}>
      {children}
    </WebSocketContext.Provider>
  )
}

export function useWebSocket() {
  const context = useContext(WebSocketContext)
  if (context === undefined) {
    throw new Error('useWebSocket must be used within a WebSocketProvider')
  }
  return context
}

// Hook для подписки на WebSocket события
export function useSocketEvent<T = any>(
  event: string,
  handler: (data: T) => void,
  deps: React.DependencyList = []
) {
  const { subscribe, unsubscribe } = useWebSocket()

  useEffect(() => {
    subscribe(event, handler)
    
    return () => {
      unsubscribe(event, handler)
    }
  }, [event, ...deps])
}

// Hook для отправки WebSocket события
export function useSocketEmit() {
  const { emit } = useWebSocket()
  return emit
}

// Hook для статуса подключения
export function useSocketConnection() {
  const { connected, reconnect } = useWebSocket()
  return { connected, reconnect }
}